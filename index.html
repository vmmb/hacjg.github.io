<!DOCTYPE html>
<html> 
  <head>
    <title>JOGOS</title> 
  </head>
<div class="header">
  <h1>Jogos em java script</h1>
  <p>Projeto HAC da Joana</p>
</div>	
	
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>


 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(1000, 500); 
     // frameRate(30);
        
      // Paste code from Khan Academy here:
	    // COLOCAR O JOGO AQUI
	    
	    /**
 * A Khan Academy version of the classic arcade game
 * "Snake"
 *
 * Use the arrow keys to move the star around and
 * eat the avatars/grow the snake.
 *
 * Try changing the values in the SETTINGS section!
 *
 * Updates
 * =======
 * 2012-12-30
 * - Made snake respond better to keypresses
 * - Made code more readable
 */

///////////// SETTINGS /////////////

// number of {rows|columns}
var N = 20;

// starting length of snake
// click "Restart" if you change this
var START_LENGTH = 1;

// increase to slow down the game
var GAME_SPEED = 3;

// how many cycles to wait before letting the
// user restart
var GAME_OVER_TIMEOUT = 20;

// if false, game over when snake moves beyond
// game boundaries
var WRAP_AROUND = true;


///////////// GLOBAL VARIABLES /////////////

var apple; // the avatar to be eaten next
var snake;

var gameOver; // true when the game is over
var gameOverTimer;

// height is the canvas height
var rowHeight = height / N;
// keep track of arrow keypresses
var keystack = [];


///////////// IMAGE VARIABLES /////////////


var mrpink =loadImage("avatars/mr-pink.png");
	
	    //image(b, 0, 0);
    
	    
var star = getImage("cute/Star");
var oldspice = getImage("avatars/old-spice-man");
//var mrpink = getImage("avatars/mr-pink");
var marcimus = getImage("avatars/marcimus");
var pants = getImage("avatars/mr-pants");
var squid = getImage("avatars/orange-juice-squid");
var purple = getImage("avatars/purple-pi");
var images = [oldspice, mrpink, marcimus,
              pants, squid, purple];


///////////// UTILITY FUNCTIONS /////////////

// generate a random integer
var randomInt = function(min, max) {
    var num = random(min, max);
    return floor(num);
};

// a generic timer function
var Timer = function(limit) {
    // initialize
    var t = limit;
    return {
        reset: function() {
            t = limit;
        },
        decr: function() {
            if (t > 0) {
                t -= 1;
            } else {
                t = 0;
            }
        },
        isUp: function() {
            return t === 0;
        }
    };
};

// record key presses
var keyPressed = function() {
    if (!gameOver) {
        if (keyCode === RIGHT || keyCode === LEFT ||
            keyCode === UP || keyCode === DOWN) {
            keystack.push(keyCode);
        }
    }
};


///////////// DRAWING FUNCTIONS /////////////

var drawUnit = function(row, col, i) {
    var h = rowHeight;
    var x = col * h;
    var y = row * h;
    image(images[i], x, y, h, h);
};


var drawBackground = function(opacity) {
    fill(36, 36, 36, opacity);
    rect(0, 0, height, height);
};

var drawGrid = function() {
    stroke(46, 46, 46);
    for (var i = 0; i < N; i += 1) {
        var x = i / N * height;
        line(x, 0, x, height);
        line(0, x, height, x);
    }
};

var drawGameOverScreen = function() {
    drawBackground(150);
    var font = createFont("monospace", 20);
    textFont(font, 20);
    textSize(60);
    fill(49, 201, 26);
    text("GAME OVER", 38, 175);
    textSize(26);
    text("Score: " + snake.score(), 132, 239);
    if (gameOverTimer.isUp()) {
        textSize(16);
        text("Press any key to start over.", 66, 314);
    }
};


///////////// APPLE /////////////

var Apple = function() {

    this.init = function() {
        this.row = randomInt(0, N);
        this.col = randomInt(0, N);
        this.img = randomInt(0, images.length);
    };

    this.positionMatch = function(row, col) {
        return this.row === row && this.col === col;
    };

    this.draw = function() {
        stroke(69, 69, 69);
        strokeWeight(1);
        fill(20, 20, 20);
        var h = rowHeight;
        var x = (this.col + 0.5) * h;
        var y = (this.row + 0.5) * h;
        ellipse(x, y, h * 1.5, h * 1.5);
        drawUnit(this.row, this.col, this.img);
    };

    this.init();
};


///////////// SNAKE /////////////

var Snake = function() {
    var rowArr = []; // row index of each body part
    var colArr = []; // column index of each body part
    var imgArr = []; // index of image for each body part
    var direction; // current direction of snake movement
    var nextDirection; // direction in the next frame

    var score; // number of apples this snake has eaten

    var init = function() {
        // start with a brand new snake
        rowArr = [];
        colArr = [];
        imgArr = [];

        // start the snake off in the upper left corner
        // the last element is the head
        for (var i = 0; i < START_LENGTH; i += 1) {
            rowArr.push(0);
            colArr.push(i);
            // generate a random image for each body
            // segment
            imgArr.push(randomInt(0, images.length));
        }

        // start snake moving to the right
        direction = RIGHT;

        score = 0;
    };

    // delta (change increment) for the snake's movement
    var getDelta = function(direction) {
        var row = 0;
        var col = 0;
        if (direction === DOWN) {
            row = 1;
        } else if (direction === UP) {
            row = -1;
        } else if (direction === LEFT) {
            col = -1;
        } else if (direction === RIGHT) {
            col = 1;
        }
        return {row: row, col: col};
    };

    // set index so that it's within the bounds [0, N-1]
    var makeInBounds = function(index, wrapAround) {
        if (!wrapAround) {
            if (index === N || index === -1) {
                gameOver = true;
                return;
            }
        } else {
            if (index === N) {
                index = 0;
            } else if (index === -1) {
                index = N;
            }
        }
        return index;
    };

    // true if a snake segment exists at (row, col)
    var segmentAt = function(row, col) {
        var len = rowArr.length;
        for (var i = 0; i < len; i += 1) {
            if (row === rowArr[i] && col === colArr[i]) {
                return true;
            }
        }
        return false;
    };

    var changeDirection = function() {
        var dir = direction;
        // by default the next direction will be the
        // same as the current direction
        nextDirection = dir;

        if (keystack.length) {
            var key = keystack.pop();
            if (dir === RIGHT || dir === LEFT) {
                if (key === UP || key === DOWN) {
                    nextDirection = key;
                }
            } else if (dir === UP || dir === DOWN) {
                if (key === RIGHT || key === LEFT) {
                    nextDirection = key;
                }
            }
        }
    };

    this.move = function(apple) {
        // don't move unless the frame number is a
        // multiple of GAME_SPEED
        if (frameCount % GAME_SPEED !== 0) {
            return;
        }

        changeDirection();

        // get snake "head"
        var row = rowArr[rowArr.length-1];
        var col = colArr[colArr.length-1];

        // get next movement
        direction = nextDirection;
        var delta = getDelta(direction);
        var rowNext = row + delta.row;
        var colNext = col + delta.col;
        rowNext = makeInBounds(rowNext, WRAP_AROUND);
        colNext = makeInBounds(colNext, WRAP_AROUND);

        // if the snake collides with itself, game over
        if (segmentAt(rowNext, colNext)) {
            gameOver = true;
        }

        // exit before advancing the snake
        if (gameOver) {
            return;
        }

        // if the next movement lands on the apple
        if (apple.positionMatch(rowNext, colNext)) {
            // add it to the snake tail
            imgArr.unshift(apple.img);
            apple.init();
            score++;
        } else {
            // otherwise, "move" the snake by removing
            // the tail segment
            rowArr.shift();
            colArr.shift();
        }

        // "move" the snake by adding a new segment to
        // the head (note that imgArr is not changed)
        rowArr.push(rowNext);
        colArr.push(colNext);
    };

    this.draw = function() {
        fill(255, 64, 64);
        var h = rowHeight;
        var len = rowArr.length;
        for (var i = 0; i < len; i += 1) {
            if (i === len - 1) {
                // draw a star for the head
                var x = colArr[i] * h;
                var y = (rowArr[i] - 0.7) * h;
                image(star, x, y, h, h * 2);
            } else {
                // use the image for everything else
                drawUnit(rowArr[i], colArr[i], imgArr[i]);
            }
        }
    };

    this.score = function() {
        return score;
    };

    init();
};


///////////// START GAME /////////////

var startGame = function() {
    snake = new Snake();
    apple = new Apple();

    gameOverTimer = Timer(GAME_OVER_TIMEOUT);
    gameOver = false;
};

// begin with a new game
startGame();


///////////// MAIN GAME LOOP /////////////

var draw = function() {
    drawBackground(255);
    drawGrid();

    snake.draw();
    apple.draw();

    if (!gameOver) {
        snake.move(apple);
    } else {
        drawGameOverScreen();
        // don't let the user restart the game
        // until the timer is up
        if (keyIsPressed && gameOverTimer.isUp()) {
            startGame();
        } else {
            gameOverTimer.decr();
        }
    }
};

/**
Arrowhead Co. Speaking
Hello there!
I've been a little inactive lately (lots of schoolwork ;-;)
But it's fine.
This is my first release in... 2 months.
Hope you enjoy!
Check out my profile:
https://www.khanacademy.org/profile/malksmogenmdavid/projects
Check my latest release here:
https://www.khanacademy.org/computer-programming/tunnel-drop-2-wip/6282256811393024
**/
var main = function(){
noStroke();
textAlign(CENTER, CENTER);
smooth();
var clique = false, acc = 0;
var CreateFont = (function () {
    return this.Function ( "gfName", 
        "gfName = gfName.replace (/\\s+/g, '+');" + 
        "var subsets = Array.prototype.slice.call(arguments, 1, arguments.length - 1);" + 
        "var url = 'https://fonts.googleapis.com/css?family=' + gfName + ( subsets.length > 0 ? '&amp;subset=' + subsets : ''), callback = arguments[arguments.length - 1];" +
        "var gfs = document.querySelectorAll('link[href=\"' + url+'\"]');" + 
        "if (!gfs.length) {" + 
            "var f = document.createElement('link');" + 
            "f.setAttribute('rel', 'stylesheet');" + 
            "f.setAttribute('type', 'text/css');" + 
            "f.onload = callback;" +    
            "f.setAttribute('href', url);" + 
            "document.head.appendChild(f);" + 
        "} else if (typeof callback === 'function') {" + 
            "callback.call(gfs[0]);" + 
        "}"
    );
})();
CreateFont("Bangers");
var B = createFont("Bangers");
var maxHeight = 100;
var Block = function(x, y, l, w, h, f){
    this.x = x * pow(3, 0.5) / 2 + y * pow(3, 0.5) / 2;
    this.y = - y * 1 / 2 + x * 1 / 2;
    
    this.l = l;
    this.w = w;
    this.h = h;
    this.origh = h;
    
    this.fall = 0;
    
    this.xFactor = pow(3, 0.5) / 2;
    this.yFactor = 1 / 2;
    
    this.f = f;
    this.origf = f;
    
    this.allBump = random() * 100;
    this.accBump = 0;
    this.changeBump = 0;
    this.prop = random() / 2 + 0.5;
};
Block.prototype.display = function() {
    stroke(0, 10);
    strokeWeight(2);
    fill(blendColor(blendColor(this.f, color(0, 0, 0), SOFT_LIGHT), color(0, 0, 0), SOFT_LIGHT));
    quad(this.x, this.y, this.x, this.y - this.h, this.x + this.l * this.xFactor, this.y - this.h - this.l * this.yFactor, this.x + this.l * this.xFactor, this.y - this.l * this.yFactor);
    fill(blendColor(this.f, color(0, 0, 0), SOFT_LIGHT));
    quad(this.x, this.y, this.x, this.y - this.h, this.x - this.w * this.xFactor, this.y - this.h - this.w * this.yFactor, this.x - this.w * this.xFactor, this.y - this.w * this.yFactor);
    fill(this.f);
    quad(this.x - this.w * this.xFactor, this.y - this.h - this.w * this.yFactor,  this.x, this.y - this.h, this.x + this.l * this.xFactor, this.y - this.h - this.l * this.yFactor, this.x - this.w * this.xFactor + this.l * this.xFactor, this.y - this.h - this.w * this.yFactor - this.l * this.yFactor);
    
    noStroke();
};
Block.prototype.animate = function() {
    this.f = lerpColor(color(0), this.origf, this.h / (maxHeight + this.origh - this.fall));
    this.h = this.accBump * this.prop + this.origh - this.fall;
    
    if(this.accBump < this.allBump){
        this.accBump -= (this.accBump - this.allBump) / 2;
    } else {
        this.accBump -= (this.accBump - 0) / 100;    
    }
    
    this.changeBump -= (this.changeBump - this.allBump)/3;
    if(abs(this.changeBump - this.allBump) < 3){
        this.allBump = random() * maxHeight;    
    }
};
var blocks = [];
for(var i = 0; i < 13; i++){
    for(var j = 0; j < 13; j++){
        blocks.push(new Block(50 * i + 250, (10 - j) * 50 - 750, 50, 50, 475, color(j*25, j*8, 255-j*25)));    
    }
}
var signum = function(x){
    if(x < 0){ return 1; } else { return 0; }
};
var Title = [1000, 10000];
draw = function() {
    background(0, 0, 0);
    
    pushMatrix();
        translate(width / 2, height / 2);
        
        for(var i = 0; i < blocks.length; i++){
            blocks[i].display();
            blocks[i].animate();
        }
    popMatrix();
    
    pushMatrix();
        translate(width / 2 - 40 - Title[0] * signum(Title[0]) * 1.73, 95 - Title[0]);
        scale(0.4, 0.5);
        rotate(-24.5);
        scale(2.5, 1);
        
        for(var i = 0; i < 20; i++){
            fill(0);
            textFont(B, 40);
            text("Jogos", -30 + i*1.5, 70 + i*4.5);
        }
        
        fill(255);
        textFont(B, 40);
        text("Jogos", 0, 160);
    popMatrix();
    
    pushMatrix();
        translate(width / 2 - 50 - Title[1] * signum(Title[1]) * 1.73, 100 - Title[1]);
        scale(0.4, 0.5);
        rotate(-24.5);
        scale(2.5, 1);
        
        for(var i = 0; i < 20; i++){
            fill(0);
            textFont(B, 150);
            text("Joana", -30 + i*1.5, -60 + i*4.5);
        }
        
        fill(255);
        textFont(B, 150);
        text("Joana", 0, 30);
    popMatrix();
    
    if(clique){
        blocks[blocks.length - 1].fall -= (blocks[blocks.length - 1].fall - 1000) / 10;    
        for(var i = blocks.length - 2; i >= 0; i--){
            if(blocks[i + 1].fall > 50){
                blocks[i].fall -= (blocks[i].fall - 1000) / 20;    
            }
        }
        Title[0] -= acc;
        Title[1] -= acc;
        acc += 1.3;
    } else {
        Title[0] -= Title[0] / 4;
        Title[1] -= Title[1] / 4;    
    }
    
    fill(0, acc);
    rect(0, 0, width, height);
    
    if(acc >= 255){
        clique = false;
        Title = [1000, 10000];
        maxHeight = 100;
        acc = 0;
        blocks = [];
        for(var i = 0; i < 13; i++){
            for(var j = 0; j < 13; j++){
                blocks.push(new Block(50 * i + 250, (10 - j) * 50 - 750, 50, 50, 475, color(j*25, j*8, 255-j*25)));    
            }
        }
    }
};
mousePressed = function(){
    if(round(Title[1]) === 0){ 
        clique = true;   
    }
};
};
main();
	    
	    
	    
	    
	  /*  noStroke();
		background(0, 0, 0);
		var r = 255;
		var g = 90;
		var b = 0;
		for (var i=0;i<360;i+=30){
		   fill(r, g, b); 
		   r -= 21;
		   g += 13;
		   b += 21;
		pushMatrix();
		translate(200,200);
		rotate(i);
		rect(0, 0, 150, 15);
		popMatrix();
		}
		noStroke();*/
	    
    }};
  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>
